<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Seth Dworman" />
  <meta name="description" content="" />
  
  
  <title>
    
      Live Transcription with Twilio and Google using Java 
      
      
      |
    
     Seth&#39;s blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/icons8-espresso-cup-100-newest.png">
    <link rel="icon" href="/images/icons8-espresso-cup-100-newest.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FG2L3F19SM"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-FG2L3F19SM');
    </script>
  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/seth-datathon-square2.jpg" alt="">
      
    </a>
    <div class="nickname"><a href="/">sethmachine</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Blog</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Live Transcription with Twilio and Google using Java</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-11-18 16:17:22
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Java/" title="Java">
                    #Java
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Dropwizard/" title="Dropwizard">
                    #Dropwizard
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Twilio/" title="Twilio">
                    #Twilio
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Transcription/" title="Transcription">
                    #Transcription
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/AI/" title="AI">
                    #AI
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Calling/" title="Calling">
                    #Calling
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Google/" title="Google">
                    #Google
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Gcloud/" title="Gcloud">
                    #Gcloud
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Speech-to-Text/" title="Speech to Text">
                    #Speech to Text
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Websockets/" title="Websockets">
                    #Websockets
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <img src="machine-talking-on-phone.jpeg" alt="AI talking over the phone" width="65%" />

<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This article provides a detailed guide on how to create your own Java live transcription service with Twilio.  There already exist guides for <a target="_blank" rel="noopener" href="https://www.twilio.com/blog/transcribe-phone-calls-text-real-time-twilio-vosk">Python</a> and <a target="_blank" rel="noopener" href="https://www.twilio.com/blog/live-transcribing-phone-calls-using-twilio-media-streams-and-google-speech-text">Node.js</a>.  Live speech to text (or live transcription) is the capability to turn spoken human language into text on demand as each person talks.  This capability powers many well known products today like Amazon’s Alexa or Apple’s Siri.  Live transcription contrasts with batch or offline transcription, which operates on already made recordings.  The online (live) nature of this makes it a harder problem and requires a different software engineering approach than the usual CRUD approach applicable to simpler systems.</p>
<p>Before getting started, you’ll need the following accounts or tools installed:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.twilio.com/try-twilio">A Twilio account</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.google.com/free">A Google Cloud account</a><sup>*</sup></li>
<li><a target="_blank" rel="noopener" href="https://www.jetbrains.com/idea/download/">IntelliJ Java IDE</a> or equivalent</li>
<li><a target="_blank" rel="noopener" href="https://maven.apache.org/">Maven</a></li>
<li><a target="_blank" rel="noopener" href="https://ngrok.com/docs/getting-started/">ngrok</a></li>
<li><a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/piesocket-websocket-teste/oilioclnckkoijghdniegedkbocfpnip">PieSocket WebSocket Tester</a></li>
</ul>
<p>If you would like to dive straight into the code, the demo source code is available in a public GitHub repository.  You may still need to reference this guide for setting up the demo.  </p>
<ul>
<li>GitHub: <a target="_blank" rel="noopener" href="https://github.com/sethmachine/twilio-live-transcription-demo-public">https://github.com/sethmachine/twilio-live-transcription-demo-public</a></li>
</ul>
<p><sup>*</sup>I recommend Google Cloud Speech To Text as it’s the easiest to set up with live transcription, but it could be substituted for any other cloud provider of speech to text that offers a similar streaming API.  </p>
<h2 id="WebSockets-Approach"><a href="#WebSockets-Approach" class="headerlink" title="WebSockets Approach"></a>WebSockets Approach</h2><p>Live transcription’s real time nature is challenging and requires using real time communication protocols that vanilla HTTP cannot accomplish easily.  End users or applications consuming the live transcription output will expect results nearly simultaneously as a person speaks.  Enter <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/WebSocket">WebSockets</a>, which allows two way communication between a server and client in real time with arbitrary data.  Using WebSockets will allow for meeting the demanding latency requirements for a live speech to text application.  Thankfully, Twilio already uses the same WebSockets technology to provide live streams of audio bytes through <a target="_blank" rel="noopener" href="https://www.twilio.com/docs/voice/api/media-streams">Media Streams</a>.  The Java web service we write will capture these audio bytes and send them to Google Cloud Speech To Text to get written natural language output.   </p>
<p>At a high level, the approach consists of the following steps:</p>
<ol>
<li>When a phone call comes in, open a WebSocket connection to Twilio Media Streams</li>
<li>Create a separate thread to stream Twilio audio bytes to Google Cloud Speech to Text</li>
<li>Create a new WebSocket connection and begin publishing Google Cloud transcription results</li>
<li>End user or application listens to the previous WebSocket connection and displays transcription results</li>
</ol>
<p>Each phone call will create 2 separate WebSocket connections: one connection for receiving the audio bytes from Twilio Media Streams, and a second WebSocket connection for publishing the Google Cloud transcription results.  This guide will omit <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/WebSocket#Security_considerations">WebSockets security issues</a> and focus entirely on functional live transcription: from phone call speech to natural language text in real time.  </p>
<p><img src="/2023/11/17/live-transcription-with-twilio-and-google/live-transcription-systems-diagram.png" alt="Live Transcription Systems Diagram"></p>
<h2 id="Setting-up-Java-web-server"><a href="#Setting-up-Java-web-server" class="headerlink" title="Setting up Java web server"></a>Setting up Java web server</h2><p>In this section we will set up foundations for the Java web server that will handle incoming phone calls, create WebSocket connections, and stream live transcriptions.  We will use the <a target="_blank" rel="noopener" href="https://www.dropwizard.io/en/latest/getting-started.html">Dropwizard framework</a> for the Java web server, as it has extensions supporting WebSockets.  It is possible to substitute Dropwizard with a different framework as long as it supports WebSockets. </p>
<p>To simplify the initial setup and boilerplate, I have created the <a target="_blank" rel="noopener" href="https://github.com/sethmachine/dropwizard-guice-template">dropwizard-guice-template repo</a> to keep the focus on the business logic for live transcription.  The steps below are for IntelliJ IDEA Community Edition.  </p>
<ol>
<li>Clone the template repo: <code>git clone https://github.com/sethmachine/dropwizard-guice-template</code></li>
<li>Open the project <code>dropwizard-guice-template</code> in IntelliJ.  It should appear as shown in the screenshot below:<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/dropwizard-guice-template-in-intellij.png" alt="Dropwizard Guice Template in IntelliJ"><br> There are several files here and packages.  Some of the key ones are:<ul>
<li><code>DropwizardGuiceTemplateApplication.java</code>: the main entry point for starting the server </li>
<li><code>dropwizard-guice-template.yml</code>: YAML runtime configuration for the server (ports, logging, etc.)</li>
<li><code>resources/SampleHttpResource.java</code>: a simple GET endpoint</li>
<li><code>resources/SampleWebsocketResource.java</code>: a websocket endpoint handling connections, messages, and disconnects</li>
</ul>
</li>
<li>Select Eclipse Adoptium 17.03 as the project Java SDK under File &gt; Project Structure &gt; Project Settings &gt; Project.  Hit Apply and OK after selecting.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/select-java-runtime-for-dropwizard-app.png" alt="Select Eclipse Java SDK"></li>
<li>Run the server:<ol>
<li>Open the Modify Run Configuration menu next to <code>DropwizardGuiceTemplateApplication</code><br> <img src="/2023/11/17/live-transcription-with-twilio-and-google/open-run-configuration.png" alt="Open Run Configuration"></li>
<li>Add the following to the CLI arguments: <code>server $ProjectFileDir$/dropwizard-guice-template.yml</code><br><img src="/2023/11/17/live-transcription-with-twilio-and-google/edit-server-run-config.png" alt="Edit Run Configuration"></li>
<li>Click Apply then OK to save the changes.  </li>
<li>Run the server in IntelliJ (open the same menu as Modify but click Run instead)<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/run-server.png" alt="Run Server Button"></li>
<li>Verify the server runs in the console.  You should see output like below:<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/running-server-in-console.png" alt="Server Running in the Console"></li>
</ol>
</li>
<li>Using an HTTP client like <code>curl</code>, verify the sample HTTP resource is working: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET localhost:8080/sample/http</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure></li>
<li> (Optionally) Rename any of the files to have the <code>TwilioLiveTranscriptionDemo</code> prefix.  For the remainder of the guide I will be referencing files and packages using so prefix: so <code>TwilioLiveTranscriptionDemoApplication.java</code> instead of <code>DropwizardGuiceTemplateApplication.java</code></li>
</ol>
<h2 id="Handle-Inbound-Calls"><a href="#Handle-Inbound-Calls" class="headerlink" title="Handle Inbound Calls"></a>Handle Inbound Calls</h2><p>With the basic server now running, we will need to configure it to handle incoming phone calls from Twilio and respond with instructions to stream the audio bytes to a websocket server.  Every purchased phone number in Twilio can be assigned an external webhook endpoint which is triggered when certain events happen, such as an incoming phone call.  We will use this webhook to instruct Twilio how to respond to incoming calls, and ultimately receive live transcription results.</p>
<p>First, create a new HTTP resource to handle incoming calls from Twilio called <code>TwilioInboundCallWebhookResource</code> as shown below:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.resources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Consumes;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.GET;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Path;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Produces;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.core.Context;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.core.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.core.MediaType;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Path(&quot;/twilio/webhooks/inbound-call&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.TEXT_XML)</span></span><br><span class="line"><span class="meta">@Consumes(MediaType.TEXT_XML)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwilioInboundCallWebhookResource</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WEBSOCKET_CONNECT_PATH</span> <span class="operator">=</span> <span class="string">&quot;twilio/websocket/audio-stream&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TwilioInboundCallWebhookResource</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GET</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getTwiml</span><span class="params">(<span class="meta">@Context</span> HttpHeaders httpHeaders)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">websocketUri</span> <span class="operator">=</span> buildWebsocketUri(httpHeaders);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> String.format(</span><br><span class="line">      <span class="string">&quot;    &lt;Response&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;      &lt;Start&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;        &lt;Stream url=\&quot;%s\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;      &lt;/Start&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;      &lt;Say&gt;This calling is being recorded.  Streaming 60 seconds of audio for live transcription.&lt;/Say&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;      &lt;Pause length=\&quot;60\&quot; /&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;    &lt;/Response&gt;&quot;</span>,</span><br><span class="line">      websocketUri</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">buildWebsocketUri</span><span class="params">(HttpHeaders httpHeaders)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> httpHeaders.getRequestHeader(<span class="string">&quot;Host&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;wss://%s/%s&quot;</span>, hostName, WEBSOCKET_CONNECT_PATH);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This HTTP resource does the following:</p>
<ul>
<li>Returns <a target="_blank" rel="noopener" href="https://www.twilio.com/docs/voice/twiml">TwiML</a> to provide instructions back to Twilio on what to do with the incoming call.  The TwiML tells Twilio to do the following:<ul>
<li>Stream the audio to a specified websocket URI (constructed in <code>TwilioInboundCallWebhookResource#buildWebsocketUri</code>)</li>
<li>Play a text to speech message informing the caller that 60 seconds of the call will be recorded and transcribed</li>
<li>End the call after 60 seconds have passed.  </li>
</ul>
</li>
<li>Constructs a URI to <code>&quot;twilio/websocket/audio-stream&quot;</code> websocket endpoint.  We will create this in the next section.  </li>
</ul>
<p>We can verify this endpoint works as expected by running the server locally and hitting it with <code>curl -X GET localhost:8080/twilio/webhooks/inbound-call</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Response</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Start</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Stream</span> <span class="attr">url</span>=<span class="string">&quot;wss://localhost:8080/twilio/websocket/audio-stream&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Start</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Say</span>&gt;</span>This calling is being recorded.  Streaming 60 seconds of audio for live transcription.<span class="tag">&lt;/<span class="name">Say</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Pause</span> <span class="attr">length</span>=<span class="string">&quot;60&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Response</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>In order to use it with a real phone call, we will first need to expose our local service to Twilio via ngrok and then purchase a phone number from Twilio.</p>
<h2 id="Handle-Websocket-audio-stream"><a href="#Handle-Websocket-audio-stream" class="headerlink" title="Handle Websocket audio stream"></a>Handle Websocket audio stream</h2><p>Now we will create the first websocket endpoint in our server to handle incoming audio streams from Twilio.  The nature of the stream is the audio byte representation of any sounds or voice made during the phone call.  Ultimately we will be implementing a websocket endpoint that implements the contract of <a target="_blank" rel="noopener" href="https://www.twilio.com/docs/voice/twiml/stream">TwiML™️ Voice: &lt;Stream&gt;</a>.  </p>
<p>The initial websocket resource looks like the following:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.resources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.codahale.metrics.annotation.ExceptionMetered;</span><br><span class="line"><span class="keyword">import</span> com.codahale.metrics.annotation.Metered;</span><br><span class="line"><span class="keyword">import</span> com.codahale.metrics.annotation.Timed;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.guice.GuiceWebsocketConfigurator;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.CloseReason;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnClose;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Metered</span></span><br><span class="line"><span class="meta">@Timed</span></span><br><span class="line"><span class="meta">@ExceptionMetered</span></span><br><span class="line"><span class="meta">@ServerEndpoint(value = &quot;/websocket&quot;, configurator = GuiceWebsocketConfigurator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwilioAudioStreamWebsocketResource</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(</span><br><span class="line">    TwilioAudioStreamWebsocketResource.class</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TwilioAudioStreamWebsocketResource</span><span class="params">(ObjectMapper objectMapper)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.objectMapper = objectMapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnOpen</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOnOpen</span><span class="params">(<span class="keyword">final</span> Session session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    LOG.info(</span><br><span class="line">      <span class="string">&quot;[sessionId: &#123;&#125;] Websocket session connection opened: &#123;&#125;&quot;</span>,</span><br><span class="line">      session.getId(),</span><br><span class="line">      session</span><br><span class="line">    );</span><br><span class="line">    session.getAsyncRemote().sendText(<span class="string">&quot;Ready to receive live transcription results&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.session = session;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMessage</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOnMsg</span><span class="params">(<span class="keyword">final</span> Session session, String message)</span> &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;[sessionId: &#123;&#125;] Got message: &#123;&#125;&quot;</span>, session.getId(), message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnClose</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOnClose</span><span class="params">(<span class="keyword">final</span> Session session, CloseReason cr)</span> &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;Closed connection! reason: &#123;&#125;, session: &#123;&#125;&quot;</span>, cr, session);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We will also need to update <code>TwilioLiveTranscriptionDemoApplication.java</code> and change the <code>ServerEndpointConfig config</code> to match the new websocket resource path like so:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> supplier is required to allow for lazy initialization of the guice injection</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ServerEndpointConfig</span> <span class="variable">config</span> <span class="operator">=</span> ServerEndpointConfig.Builder</span><br><span class="line">  .create(TwilioAudioStreamWebsocketResource.class, <span class="string">&quot;/twilio/websocket/audio-stream&quot;</span>)</span><br><span class="line">  .configurator(<span class="keyword">new</span> <span class="title class_">GuiceWebsocketConfigurator</span>(() -&gt; guiceBundle.getInjector()))</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure>

<p>This websocket resource does the following:</p>
<ul>
<li>Exposes a websocket endpoint via <code>&quot;/twilio/websocket/audio-stream&quot;</code>, which can be accessed locally via <code>ws://localhost:8080/twilio/websocket/audio-stream</code>.  </li>
<li>Implements <code>@OnOpen</code>: when a first websocket connection is made, this block of code is triggered.  </li>
<li>Implements <code>@OnMessage</code>: whenever a message is sent (from the client to the server), this block of code is triggered.  In our case, Twilio send over <a target="_blank" rel="noopener" href="https://www.twilio.com/docs/voice/twiml/stream#message-media">Media Messages</a> which include raw audio bytes.  Right now this is represented as a raw String but we’ll change this later in the guide to a more meaningful object representation.  </li>
<li>Implements <code>@OnClose</code>: executed when the connection is closed.  This can be useful for logging and cleaning up resources.  </li>
<li>Declares a private <code>Session</code> object.  Each session is stateful and represents an entire websocket connection from its beginning to end.  This object will be key to send back transcription results to the client/end user. </li>
</ul>
<p>We can verify the websocket resource is working as expected by using the Chrome extension <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/piesocket-websocket-teste/oilioclnckkoijghdniegedkbocfpnip">PieSocket WebSocket Tester</a>:</p>
<ol>
<li>Run the Java server locally (via <code>TwilioLiveTranscriptionDemoApplication</code>)</li>
<li>Open PieSocket WebSocket Tester in Chrome browser.  </li>
<li>Enter the websocket URL <code>ws://localhost:8080/twilio/websocket/audio-stream</code> and hit Connect:<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/connect-pie-websocket.png" alt="Connect Pie WebSocket to localhost"></li>
<li>Observe the following in the PieSocket console:<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/pie-websocket-connected-basic.png" alt="Pie WebSocket Initial Connection Basic"></li>
<li>At the same time, there should be output in the Java server console:<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/server-websocket-connection-initial-output.png" alt="Server Initial Output when connecting via websocket"></li>
</ol>
<p>Later on we will add proper Java objects to model all the messages coming in from Twilio, and then build logic to send these to Google Cloud Speech to Text for live transcription.  </p>
<h2 id="Expose-server-with-ngrok"><a href="#Expose-server-with-ngrok" class="headerlink" title="Expose server with ngrok"></a>Expose server with ngrok</h2><p><a target="_blank" rel="noopener" href="https://ngrok.com/docs/getting-started/">ngrok</a> allows for exposing a local service to the public internet.  This step is necessary because Twilio webhooks require publicly exposed endpoints.  While this may seem insecure, the URLs that ngrok generates for forwarding are hard to guess and thus provide security through obfuscation.  In addition, each time ngrok is run again, a different public URL will be generated.    </p>
<p>After ngrok is installed, run ngrok and verify it is correctly exposing the server:</p>
<ol>
<li> Run the Java server (via running <code>TwilioLiveTranscriptionDemoApplication</code> in IntelliJ)</li>
<li>On a separate command line, run <code>ngrok http 8080</code>.  This will expose port 8080 publicly.  </li>
<li>From the ngrok output, find the public forwarding URL (see below image):<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/ngrok-running-first-time.png" alt="Ngrok running with forwarding URL"></li>
<li>In this example, the URL is <code>https://31d0-2601-189-8000-c3f0-7c5c-caaa-3da3-78f1.ngrok-free.app</code>.  Note your actual forwarding URL will be different (but have a similar pattern of alphanumeric characters).  </li>
<li>Verify the endpoint is now exposed, either via copying in a browser URL or using <code>curl -X GET https://31d0-2601-189-8000-c3f0-7c5c-caaa-3da3-78f1.ngrok-free.app/twilio/webhooks/inbound-call</code>:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">Response</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Start</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Stream</span> <span class="attr">url</span>=<span class="string">&quot;wss://31d0-2601-189-8000-c3f0-7c5c-caaa-3da3-78f1.ngrok-free.app/twilio/websocket/audio-stream&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Start</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Say</span>&gt;</span>This calling is being recorded.  Streaming 60 seconds of audio for live transcription.<span class="tag">&lt;/<span class="name">Say</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Pause</span> <span class="attr">length</span>=<span class="string">&quot;60&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Response</span>&gt;</span></span><br></pre></td></tr></table></figure>
In the response the stream URL also points to the exposed ngrok endpoint.  This will make sure Twilio sends audio byte streams to the same server.  </li>
</ol>
<h2 id="Buy-and-configure-a-phone-number"><a href="#Buy-and-configure-a-phone-number" class="headerlink" title="Buy and configure a phone number"></a>Buy and configure a phone number</h2><p>In this section we will verify the server is working with a real phone call.  First we need to purchase a phone number from Twilio and then configure it to communicate with the Java server for inbound calls.  For this part of the guide, the Java server needs to be running with ngrok forwarding enabled.  Keep the ngrok forwarding URL ready for copying.  See <a href="#exposing-server-with-ngrok">Exposing server with ngrok</a> for how to do this.  Note that each time ngrok is turned off, the forwarding URL will be different than last time, so make sure you have copied the most recent one.    </p>
<ol>
<li>In the Twilio console, navigate to Develop &gt; Phone Numbers &gt; Manager &gt; Buy a number<br> <img src="/2023/11/17/live-transcription-with-twilio-and-google/buy-twilio-phone-number-part-1.png" alt="Buy Twilio Phone Number part 1"></li>
<li>(Optional) Search for any particular phone number that has voice capability.  In this case I recommend any cheap phone number in the U.S.</li>
<li>Buy the phone number.  This will cost actual money but it is a very small monthly charge (e.g. 25 cents a month) and you can later delete the phone number once finished to avoid future monthly costs.  Some Twilio trial accounts come with free credits so you may not end up paying for anything at all until the credits are used up.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/buy-twilio-phone-number-part-2.png" alt="Buy Twilio Phone Number part 2"></li>
<li>After successfully purchasing, open the configuration for the newly purchased phone number<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/buy-twilio-phone-number-part-3.png" alt="Buy Twilio Phone Number part 3"></li>
<li>Under Voice Configuration, replace the URL for the webhook <strong>A call comes in</strong> with the ngrok forwarding URL and the server endpoint path <code>/twilio/webhooks/inbound-call</code>.  E.g. it should look like <code>https://31d0-2601-189-8000-c3f0-7c5c-caaa-3da3-78f1.ngrok-free.app/twilio/webhooks/inbound-call</code>.  Your particular ngrok forwarding URL will be unique and different from the one in the guide.  </li>
<li>Set the HTTP select box method to HTTP GET.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/buy-twilio-phone-number-part-4.png" alt="Buy Twilio Phone Number part 4"></li>
<li>Scroll to the bottom of the page and click Save Configuration.<br> <img src="/2023/11/17/live-transcription-with-twilio-and-google/buy-twilio-phone-number-part-5.png" alt="Buy Twilio Phone Number part 5"></li>
<li> Keep a copy of the purchased phone number, we will be calling it regularly to test the live transcription functionality.  </li>
</ol>
<p>Congratulations!  You’ve purchased your first phone number and configured it to send webhooks to a Java server running locally. It is important to note: <strong>each time ngrok is stopped and started again, the phone number webhook will need to be reconfigured with the most recent ngrok forwarding URL.</strong>  </p>
<p>Now to test the server.  For this next part you’ll need a way to dial the purchased phone number.  I use my personal cell phone but any method of dialing it should work.  Keep the Java server console open to observe the incoming web traffic from Twilio.  </p>
<ol>
<li> Dial the purchased phone number!  </li>
<li>You should hear a message saying “This calling is being recorded.  Streaming 60 seconds of audio for live transcription.”</li>
<li>Observe the console output of the server:<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/console-output-twilio-connection-part-1.png" alt="Console output for Twilio incoming call"><br>Several key parts are annotated here:<ul>
<li>the initial inbound call webhook being hit by Twilio</li>
<li>the websocket connection being opened</li>
<li>the first media stream message being sent over the websocket by Twilio</li>
</ul>
</li>
<li>Afterwards, you should see a continuous stream of messages being received by the websocket.  These messages contain a payload of the captured audio bytes of the phone call.  We will soon send these bytes to Google Cloud Speech To Text to get natural language text back.<br> <img src="/2023/11/17/live-transcription-with-twilio-and-google/console-output-twilio-connection-part-2.png" alt="Console output for Twilio incoming call"><ul>
<li>The <code>&quot;payload&quot;</code> key of each message is the base 64 representation of the audio bytes.</li>
<li>Speech to text to will transcribe each payload into written text.  </li>
</ul>
</li>
<li>Hang up the call or wait 60 seconds for the call to end.  </li>
</ol>
<p>Note if instead you hear “An application error has occurred”, this means something went wrong with the Twilio webhook.  Double check the server is running, ngrok is forwarding port 8080, and the ngrok forwarding URL on the purchased phone number webhook matches the current ngrok forwarding URL.  For more debugging see: <a target="_blank" rel="noopener" href="https://www.twilio.com/docs/voice/troubleshooting#an-application-error-has-occurred-on-your-call">Troubleshooting Voice Calls</a>.  </p>
<h2 id="Model-Twilio-Stream-messages"><a href="#Model-Twilio-Stream-messages" class="headerlink" title="Model Twilio Stream messages"></a>Model Twilio Stream messages</h2><p>In the previous sections we were able to successfully open a websocket audio stream from an incoming call.  However, the current representation of the messages are plain Java <code>String</code> objects.  We will need to deserialize these into actual typed objects in order to reference various fields such as the <code>&quot;payload&quot;</code> and to understand what overall is happening in the stream.  Thankfully Twilio has clear documentation on the schema of each type of Media Stream message: <a target="_blank" rel="noopener" href="https://www.twilio.com/docs/voice/twiml/stream#message-connected">Twilio Media Stream Messages</a>.  </p>
<p>For a bird’s eye view see all the model files in the demo repo: <a target="_blank" rel="noopener" href="https://github.com/sethmachine/twilio-live-transcription-demo-public/tree/main/src/main/java/io/sethmachine/twiliolivetranscriptiondemo/core/model/twilio/stream">Twilio Live Transcription Demo Media Streams Models</a></p>
<ol>
<li> Create a new <code>core.model.twilio.stream</code> package under the root package.  E.g. the full package path on my implementation would be: <code>package io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream</code>.  </li>
<li>Create two additional subpackages, <code>messages</code> for modeling the stream messages, and <code>mediaformat</code> for modeling the audio format of each message.</li>
<li> Create another subpackage under <code>core.model.twilio.stream.messages</code> called <code>payloads</code>.  This will model information specific to the nested payloads on each message.  </li>
<li>Create an immutable class <code>MediaFormatIF</code> in the <code>mediaformat</code> package.  This class will provide information on the audio format of each media message, so we can tell Google Speech To Text how to interpret the audio bytes. <figure class="highlight java"><figcaption><span>MediaFormatIF.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.mediaformat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hubspot.immutables.style.HubSpotStyle;</span><br><span class="line"><span class="keyword">import</span> org.immutables.value.Value.Immutable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="meta">@HubSpotStyle</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaFormatIF</span> &#123;</span><br><span class="line">  String <span class="title function_">getEncoding</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getSampleRate</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getChannels</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Create immutable classes to model the nested payloads of incoming messages: <code>MediaMessagePayloadIF.java</code>, <code>StartMessagePayloadIF</code>, and <code>StopMessagePayloadIF</code>.  Create these under the <code>core.model.twilio.stream.messages.payloads</code> package: <figure class="highlight java"><figcaption><span>StartMessagePayloadIF.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hubspot.immutables.style.HubSpotStyle;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.mediaformat.MediaFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.immutables.value.Value.Immutable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="meta">@HubSpotStyle</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StartMessagePayloadIF</span> &#123;</span><br><span class="line">  String <span class="title function_">getStreamSid</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getAccountSid</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getCallSid</span><span class="params">()</span>;</span><br><span class="line">  List&lt;String&gt; <span class="title function_">getTracks</span><span class="params">()</span>;</span><br><span class="line">  Map&lt;String, String&gt; <span class="title function_">getCustomParameters</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  MediaFormat <span class="title function_">getMediaFormat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><figcaption><span>MediaMessagePayloadIF.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hubspot.immutables.style.HubSpotStyle;</span><br><span class="line"><span class="keyword">import</span> org.immutables.value.Value.Immutable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="meta">@HubSpotStyle</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaMessagePayloadIF</span> &#123;</span><br><span class="line">  String <span class="title function_">getTrack</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getChunk</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getTimestamp</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getPayload</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><figcaption><span>StopMesssagePayloadIF.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.immutables.value.Value.Immutable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hubspot.immutables.style.HubSpotStyle;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="meta">@HubSpotStyle</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StopMessagePayloadIF</span> &#123;</span><br><span class="line">  String <span class="title function_">getAccountSid</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getCallSid</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Create <code>MessageEventType.java</code> enum class to model the four kinds of messages Twilio can send through the audio stream.  This will help to deserialize each incoming Twilio stream message into the equivalent Java model.   <figure class="highlight java"><figcaption><span>MessageEventType.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonCreator;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonValue;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">MessageEventType</span> &#123;</span><br><span class="line">  CONNECTED(<span class="string">&quot;connected&quot;</span>),</span><br><span class="line">  START(<span class="string">&quot;start&quot;</span>),</span><br><span class="line">  MEDIA(<span class="string">&quot;media&quot;</span>),</span><br><span class="line">  STOP(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, MessageEventType&gt; EVENT_TO_ENUM_MAP = Arrays</span><br><span class="line">    .stream(MessageEventType.values())</span><br><span class="line">    .collect(</span><br><span class="line">      Collectors.toUnmodifiableMap(MessageEventType::getEventName, Function.identity())</span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String eventName;</span><br><span class="line"></span><br><span class="line">  MessageEventType(String eventName) &#123;</span><br><span class="line">    <span class="built_in">this</span>.eventName = eventName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@JsonValue</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getEventName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> eventName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@JsonCreator</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> MessageEventType <span class="title function_">fromEventName</span><span class="params">(String eventName)</span> &#123;</span><br><span class="line">    <span class="type">MessageEventType</span> <span class="variable">maybeEntry</span> <span class="operator">=</span> EVENT_TO_ENUM_MAP.get(eventName);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(maybeEntry)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">        String.format(<span class="string">&quot;Unknown value for MessageEventType enum: %s&quot;</span>, eventName)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maybeEntry;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Create a <code>StreamMessageCore.java</code> interface class.  This interface includes fields present in all types of media messages, namely the sequence number and the stream SID (a unique Twilio identifier for the stream). <figure class="highlight java"><figcaption><span>StreamMessageCore.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StreamMessageCore</span> <span class="keyword">extends</span> <span class="title class_">StreamMessage</span> &#123;</span><br><span class="line">  String <span class="title function_">getSequenceNumber</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getStreamSid</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Create models for each of the four media message types: connected, start, message, and stop: <figure class="highlight java"><figcaption><span>ConnectedMessageIF</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hubspot.immutables.style.HubSpotStyle;</span><br><span class="line"><span class="keyword">import</span> org.immutables.value.Value.Immutable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HubSpotStyle</span></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="comment">// See: https://www.twilio.com/docs/voice/twiml/stream#message-connected</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConnectedMessageIF</span> <span class="keyword">extends</span> <span class="title class_">StreamMessage</span> &#123;</span><br><span class="line">  String <span class="title function_">getProtocol</span><span class="params">()</span>;</span><br><span class="line">  String <span class="title function_">getVersion</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><figcaption><span>StartMessageIF</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAlias;</span><br><span class="line"><span class="keyword">import</span> com.hubspot.immutables.style.HubSpotStyle;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.payloads.StartMessagePayload;</span><br><span class="line"><span class="keyword">import</span> org.immutables.value.Value.Immutable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HubSpotStyle</span></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="comment">// See: https://www.twilio.com/docs/voice/twiml/stream#message-start</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StartMessageIF</span> <span class="keyword">extends</span> <span class="title class_">StreamMessageCore</span> &#123;</span><br><span class="line">  <span class="meta">@JsonAlias(&quot;start&quot;)</span></span><br><span class="line">  StartMessagePayload <span class="title function_">getStartMessagePayLoad</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><figcaption><span>MediaMessageIF</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAlias;</span><br><span class="line"><span class="keyword">import</span> com.hubspot.immutables.style.HubSpotStyle;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.payloads.MediaMessagePayload;</span><br><span class="line"><span class="keyword">import</span> org.immutables.value.Value.Immutable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HubSpotStyle</span></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaMessageIF</span> <span class="keyword">extends</span> <span class="title class_">StreamMessageCore</span> &#123;</span><br><span class="line">  <span class="meta">@JsonAlias(&quot;media&quot;)</span></span><br><span class="line">  MediaMessagePayload <span class="title function_">getMediaMessagePayload</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><figcaption><span>StopMessageIF</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAlias;</span><br><span class="line"><span class="keyword">import</span> com.hubspot.immutables.style.HubSpotStyle;</span><br><span class="line"><span class="keyword">import</span> org.immutables.value.Value.Immutable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.payloads.StopMessagePayload;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HubSpotStyle</span></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="comment">// See: https://www.twilio.com/docs/voice/twiml/stream#example-stop-message</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StopMessageIF</span> <span class="keyword">extends</span> <span class="title class_">StreamMessageCore</span> &#123;</span><br><span class="line">  <span class="meta">@JsonAlias(&quot;stop&quot;)</span></span><br><span class="line">  StopMessagePayload <span class="title function_">getStopMessagePayload</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Finally, to allow Java to know how to serialize each stream message into the appropriate message type, introduce a <code>StreamMessage.java</code> class that provides JSON subtyping information. <figure class="highlight java"><figcaption><span>StreamMessage.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAlias;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonSubTypes;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonTypeInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonTypeInfo(</span></span><br><span class="line"><span class="meta">  use = JsonTypeInfo.Id.NAME,</span></span><br><span class="line"><span class="meta">  include = JsonTypeInfo.As.EXISTING_PROPERTY,</span></span><br><span class="line"><span class="meta">  property = &quot;event&quot;,</span></span><br><span class="line"><span class="meta">  visible = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@JsonSubTypes(</span></span><br><span class="line"><span class="meta">  &#123;</span></span><br><span class="line"><span class="meta">    @JsonSubTypes.Type(value = ConnectedMessage.class, name = &quot;connected&quot;),</span></span><br><span class="line"><span class="meta">    @JsonSubTypes.Type(value = StartMessage.class, name = &quot;start&quot;),</span></span><br><span class="line"><span class="meta">    @JsonSubTypes.Type(value = MediaMessage.class, name = &quot;media&quot;),</span></span><br><span class="line"><span class="meta">    @JsonSubTypes.Type(value = StopMessage.class, name = &quot;stop&quot;),</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StreamMessage</span> &#123;</span><br><span class="line">  <span class="meta">@JsonAlias(&quot;event&quot;)</span></span><br><span class="line">  MessageEventType <span class="title function_">getMessageEventType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 This uses the media message event type to determine how to deserialize each incoming websocket message.  </li>
</ol>
<p>Now we need to make the websocket resource class, <code>TwilioInboundCallWebhookResource</code> aware of these models so it will automatically deserialize incoming Strings into its proper <code>StreamMessage</code> object.  </p>
<ol>
<li> Create a new top level package <code>service.twilio.stream</code> (the full package being <code>package io.sethmachine.twiliolivetranscriptiondemo.service.twilio.stream;</code>).  </li>
<li>Create the <code>StreamMessageDecoder.java</code> decoder class in the new subpackage.   <figure class="highlight java"><figcaption><span>StreamMessageDecoder.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.service.twilio.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.StreamMessage;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.DecodeException;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Decoder;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.EndpointConfig;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamMessageDecoder</span> <span class="keyword">implements</span> <span class="title class_">Decoder</span>.Text&lt;StreamMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(StreamMessageDecoder.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> StreamMessage <span class="title function_">decode</span><span class="params">(String s)</span> <span class="keyword">throws</span> DecodeException &#123;</span><br><span class="line">    <span class="keyword">return</span> decodeString(s)</span><br><span class="line">      .orElseThrow(() -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> String.format(<span class="string">&quot;Failed to parse string into StreamMessage: %s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DecodeException</span>(s, msg);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">willDecode</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> decodeString(s).isPresent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(EndpointConfig config)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.objectMapper = <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Optional&lt;StreamMessage&gt; <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Optional.of(objectMapper.readValue(s, StreamMessage.class));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;Failed to decode string into StreamMessage: &#123;&#125;&quot;</span>, s);</span><br><span class="line">      <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Update the <code>TwilioInboundCallWebhookResource.java</code> class to use the new stream decoder, as well as use <code>StreamMessage streamMessage</code> instead of <code>String streamMessage</code>. <figure class="highlight java"><figcaption><span>TwilioInboundCallWebhookResource.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.resources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Consumes;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.GET;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Path;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Produces;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.core.Context;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.core.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.core.MediaType;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Path(&quot;/twilio/webhooks/inbound-call&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.TEXT_XML)</span></span><br><span class="line"><span class="meta">@Consumes(MediaType.TEXT_XML)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwilioInboundCallWebhookResource</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WEBSOCKET_CONNECT_PATH</span> <span class="operator">=</span> <span class="string">&quot;twilio/websocket/audio-stream&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TwilioInboundCallWebhookResource</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GET</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getTwiml</span><span class="params">(<span class="meta">@Context</span> HttpHeaders httpHeaders)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">websocketUri</span> <span class="operator">=</span> buildWebsocketUri(httpHeaders);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> String.format(</span><br><span class="line">      <span class="string">&quot;    &lt;Response&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;      &lt;Start&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;        &lt;Stream url=\&quot;%s\&quot;/&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;      &lt;/Start&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;      &lt;Say&gt;This calling is being recorded.  Streaming 60 seconds of audio for live transcription.&lt;/Say&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;      &lt;Pause length=\&quot;60\&quot; /&gt;\n&quot;</span> +</span><br><span class="line">      <span class="string">&quot;    &lt;/Response&gt;&quot;</span>,</span><br><span class="line">      websocketUri</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">buildWebsocketUri</span><span class="params">(HttpHeaders httpHeaders)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> httpHeaders.getRequestHeader(<span class="string">&quot;Host&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;wss://%s/%s&quot;</span>, hostName, WEBSOCKET_CONNECT_PATH);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Update <code>TwilioLiveTranscriptionDemoApplication.java</code> to provide the decoder to the websocket endpoint.  Update the <code>ServerEndpointConfig config</code> variable so it looks like the following: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">final</span> <span class="type">ServerEndpointConfig</span> <span class="variable">config</span> <span class="operator">=</span> ServerEndpointConfig.Builder</span><br><span class="line">.create(TwilioAudioStreamWebsocketResource.class, <span class="string">&quot;/twilio/websocket/audio-stream&quot;</span>)</span><br><span class="line">.configurator(<span class="keyword">new</span> <span class="title class_">GuiceWebsocketConfigurator</span>(() -&gt; guiceBundle.getInjector()))</span><br><span class="line">.decoders(ImmutableList.of(StreamMessageDecoder.class))</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>To verify the media messages are being correctly deserialized, re-run the server and place another phone call to the purchased phone number.  The console output should be equivalent but there should be no serialization errors, confirming the model decoding is working.  We can now work with proper typed models for writing the Speech To Text business logic.  The console output now shows each message as a properly deserialized object:</p>
<p><img src="/2023/11/17/live-transcription-with-twilio-and-google/console-output-modeling-twilio-messages.png" alt="Console output with deserialized media messages"></p>
<h2 id="Set-up-Google-Cloud-Speech-to-Text"><a href="#Set-up-Google-Cloud-Speech-to-Text" class="headerlink" title="Set up Google Cloud Speech to Text"></a>Set up Google Cloud Speech to Text</h2><p>In this section we will now set up API access to <a target="_blank" rel="noopener" href="https://console.cloud.google.com/marketplace/product/google/speech.googleapis.com">Google Cloud Speech To Text</a>.  This will enable the server to access speech to text APIs to turn the audio bytes into natural language text.  The goal here is to create and download JSON API credentials.</p>
<h3 id="Create-credentials"><a href="#Create-credentials" class="headerlink" title="Create credentials"></a>Create credentials</h3><ol>
<li> <a target="_blank" rel="noopener" href="https://cloud.google.com/free">Create a free Google Cloud account</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/workspace/guides/create-project">In the Google Cloud console, create a new project</a>.  I named mine “Twilio Live Transcription”</li>
<li>Search for speech to text in the top search bar.  Select Cloud Speech-to-Text API.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/setup-google-cloud/search-for-speech-to-text.png" alt="Search for speech to text"></li>
<li>Click Enable to enable the speech to text API<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/setup-google-cloud/enable-speech-to-text-api.png" alt="Enable speech to text"><br> Note you may be prompted to provide billing information to enable this.  If this is your first Google Cloud account, it should come with a large amount of free credits, so you will not be charged until these are exhausted.  </li>
<li>Click Create Credentials for the speech to text API to start the process to create a JSON key file.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/setup-google-cloud/create-credentials-part-1.png" alt="Create credentials part 1"></li>
<li>Select Application Data in Credential Type setup.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/setup-google-cloud/create-credentials-part-2.png" alt="Create credentials part 2"></li>
<li>In the Service account details, name the API service account.  I chose “twilio-live-transcription-demo”.  Leave the rest of the fields as is.  </li>
<li>Grant the Owner role to the service account.  This will let it have access to all available APIs in cloud speech to text.  Hit Done afterwards.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/setup-google-cloud/create-credentials-part-3.png" alt="Create credentials part 3"></li>
<li>Under the newly created service account, create a new key.  For key type, select JSON.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/setup-google-cloud/create-credentials-part-4.png" alt="Create credentials part 4">  </li>
<li>This will immediately download the JSON key file to your computer.  Importantly, do not share this file or upload it online.  It should be stored outside any repository or codebase.  You should see the key listed in the service account now.  Note in the image below I have replaced the key with a made up string of alphanumeric characters.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/setup-google-cloud/create-credentials-part-5.png" alt="Create credentials part 5"></li>
</ol>
<p>Congratulations, we have now created JSON credentials for Google Cloud Speech To Text.  As a warning, do not store the JSON file anywhere online or version control it to a repository.  Anyone with the key file can begin using the cloud API and eventually rack up actual charges to your account.  </p>
<h3 id="Add-credentials-to-server"><a href="#Add-credentials-to-server" class="headerlink" title="Add credentials to server"></a>Add credentials to server</h3><p>The server will need the credentials to make Google Cloud API calls.  Follow these steps to do this.  </p>
<ol>
<li> Move or make a copy of the JSON credentials to folder outside of version control.  For example, I have stored mine here: <code>/Users/sethmachine/cloud/gcloud/keys/cloud-speech-to-text/12837428383-3024afs.json</code>.</li>
<li>In IntelliJ, open the edit configuration for the <code>TwilioLiveTranscriptionDemoApplication</code>.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/setup-google-cloud/edit-run-config-part-1.png" alt="Edit run config part 1"></li>
<li>Open the Environment variables menu.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/setup-google-cloud/edit-run-config-part-2.png" alt="Edit run config part 2"></li>
<li>Create a new environment variable called <code>GOOGLE_APPLICATION_CREDENTIALS</code>.  Set its value to the full path to where the JSON key file is stored on your computer.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/setup-google-cloud/edit-run-config-part-3.png" alt="Edit run config part 3"></li>
<li>Hit Apply and then OK to save this configuration change.  </li>
</ol>
<h2 id="Live-transcription-setup"><a href="#Live-transcription-setup" class="headerlink" title="Live transcription setup"></a>Live transcription setup</h2><p>In this section we will add the actual code to send audio bytes from Twilio’s media stream messages to the Google Cloud Speech To Text we set up in the previous section.  Because new audio bytes will be constantly streaming in, we cannot use blocking HTTP requests to wait for transcription results.  Thus we will need to do the following:</p>
<ul>
<li>Create a new thread pool that listens for incoming media messages and sends these to Google Cloud Speech To Text</li>
<li>Send transcription results back to the client through the websocket</li>
</ul>
<h3 id="Speech-To-Text-thread-pool"><a href="#Speech-To-Text-thread-pool" class="headerlink" title="Speech To Text thread pool"></a>Speech To Text thread pool</h3><p>The thread pool will run workers that listen for Twilio media stream messages and send these to Google Cloud until transcription results are ready.  The worker will run until the websocket connection is closed.  Thankfully Google has provided an example of how to do this “infinite transcription streaming”: <a target="_blank" rel="noopener" href="https://cloud.google.com/speech-to-text/docs/samples/speech-transcribe-infinite-streaming">Google Cloud Speech To Text Infinite Stream</a>.  I have taken this example and modified it support the websocket use case as shown below in <code>StreamingSpeechToTextRunnable.java</code>.  Be sure to create this under a new package like <code>core.concurrent.speech.google</code> for project organization.  </p>
<ol>
<li> Create new subpackages <code>core.concurrent.speech.google</code> and <code>core.model.speech.google</code>.  </li>
<li>Create a new class for transcription results output <code>TranscriptOutputMessageIF.java</code> under the model subpackage.  These are the messages the websocket will send back to the client or user.   <figure class="highlight java"><figcaption><span>TranscriptOutputMessageIF.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.speech.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.immutables.value.Value.Immutable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hubspot.immutables.style.HubSpotStyle;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HubSpotStyle</span></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TranscriptOutputMessageIF</span> &#123;</span><br><span class="line">  String <span class="title function_">getText</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">float</span> <span class="title function_">getConfidence</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">getIsFinal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Create the thread runnable class <code>StreamingSpeechToTextRunnable.java</code> under the <code>core.concurrent.speech.google</code> package.  This is the code that each worker thread will execute for each incoming phone call audio stream.  It is based on the Google infinite stream example but heavily modified to add in the websocket connection and state.   <figure class="highlight java"><figcaption><span>StreamingSpeechToTextRunnable.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.concurrent.speech.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.MessageHandler;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.google.api.gax.rpc.ClientStream;</span><br><span class="line"><span class="keyword">import</span> com.google.api.gax.rpc.ResponseObserver;</span><br><span class="line"><span class="keyword">import</span> com.google.api.gax.rpc.StreamController;</span><br><span class="line"><span class="keyword">import</span> com.google.cloud.speech.v1p1beta1.RecognitionConfig;</span><br><span class="line"><span class="keyword">import</span> com.google.cloud.speech.v1p1beta1.RecognitionConfig.AudioEncoding;</span><br><span class="line"><span class="keyword">import</span> com.google.cloud.speech.v1p1beta1.SpeechClient;</span><br><span class="line"><span class="keyword">import</span> com.google.cloud.speech.v1p1beta1.SpeechRecognitionAlternative;</span><br><span class="line"><span class="keyword">import</span> com.google.cloud.speech.v1p1beta1.StreamingRecognitionConfig;</span><br><span class="line"><span class="keyword">import</span> com.google.cloud.speech.v1p1beta1.StreamingRecognitionResult;</span><br><span class="line"><span class="keyword">import</span> com.google.cloud.speech.v1p1beta1.StreamingRecognizeRequest;</span><br><span class="line"><span class="keyword">import</span> com.google.cloud.speech.v1p1beta1.StreamingRecognizeResponse;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.assistedinject.Assisted;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.ByteString;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.speech.google.TranscriptOutputMessage;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.MediaMessage;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.StreamMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamingSpeechToTextRunnable</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">Runnable</span>, MessageHandler.Whole&lt;StreamMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(</span><br><span class="line">    StreamingSpeechToTextRunnable.class</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STREAMING_LIMIT</span> <span class="operator">=</span> <span class="number">290000</span>; <span class="comment">// ~5 minutes</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="string">&quot;\033[0;31m&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GREEN</span> <span class="operator">=</span> <span class="string">&quot;\033[0;32m&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">YELLOW</span> <span class="operator">=</span> <span class="string">&quot;\033[0;33m&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Creating shared object</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> BlockingQueue&lt;<span class="type">byte</span>[]&gt; sharedQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">BYTES_PER_BUFFER</span> <span class="operator">=</span> <span class="number">6400</span>; <span class="comment">// buffer size in bytes</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">restartCounter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;ByteString&gt; audioInput = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ByteString&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;ByteString&gt; lastAudioInput = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ByteString&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">resultEndTimeInMS</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">isFinalEndTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">finalRequestEndTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">newStream</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">bridgingOffset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">lastTranscriptWasFinal</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> StreamController referenceToStreamController;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ByteString tempByteString;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Session websocketSession;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">stopped</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">private</span> Thread worker;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">StreamingSpeechToTextRunnable</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@Assisted</span> Session websocketSession,</span></span><br><span class="line"><span class="params">    ObjectMapper objectMapper</span></span><br><span class="line"><span class="params">  )</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.websocketSession = websocketSession;</span><br><span class="line">    <span class="built_in">this</span>.objectMapper = objectMapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;Received request to stop this thread&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.stopped.set(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    ResponseObserver&lt;StreamingRecognizeResponse&gt; responseObserver = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SpeechClient</span> <span class="variable">client</span> <span class="operator">=</span> SpeechClient.create()) &#123;</span><br><span class="line">      ClientStream&lt;StreamingRecognizeRequest&gt; clientStream;</span><br><span class="line">      responseObserver =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ResponseObserver</span>&lt;StreamingRecognizeResponse&gt;() &#123;</span><br><span class="line">          ArrayList&lt;StreamingRecognizeResponse&gt; responses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(StreamController controller)</span> &#123;</span><br><span class="line">            referenceToStreamController = controller;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(StreamingRecognizeResponse response)</span> &#123;</span><br><span class="line">            responses.add(response);</span><br><span class="line">            <span class="type">StreamingRecognitionResult</span> <span class="variable">result</span> <span class="operator">=</span> response.getResultsList().get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Duration</span> <span class="variable">resultEndTime</span> <span class="operator">=</span> result.getResultEndTime();</span><br><span class="line">            resultEndTimeInMS =</span><br><span class="line">              (<span class="type">int</span>) (</span><br><span class="line">                (resultEndTime.getSeconds() * <span class="number">1000</span>) + (resultEndTime.getNanos() / <span class="number">1000000</span>)</span><br><span class="line">              );</span><br><span class="line">            <span class="type">double</span> <span class="variable">correctedTime</span> <span class="operator">=</span></span><br><span class="line">              resultEndTimeInMS - bridgingOffset + (STREAMING_LIMIT * restartCounter);</span><br><span class="line"></span><br><span class="line">            <span class="type">SpeechRecognitionAlternative</span> <span class="variable">alternative</span> <span class="operator">=</span> result</span><br><span class="line">              .getAlternativesList()</span><br><span class="line">              .get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (result.getIsFinal()) &#123;</span><br><span class="line">              isFinalEndTime = resultEndTimeInMS;</span><br><span class="line">              lastTranscriptWasFinal = <span class="literal">true</span>;</span><br><span class="line">              <span class="comment">// in actual use we would publish to a specific channel tied to the call ID</span></span><br><span class="line">              websocketSession</span><br><span class="line">                .getOpenSessions()</span><br><span class="line">                .forEach(session -&gt; &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    session</span><br><span class="line">                      .getAsyncRemote()</span><br><span class="line">                      .sendObject(</span><br><span class="line">                        objectMapper.writeValueAsString(</span><br><span class="line">                          createTranscriptOutputMessage(result.getIsFinal(), alternative)</span><br><span class="line">                        )</span><br><span class="line">                      );</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              lastTranscriptWasFinal = <span class="literal">false</span>;</span><br><span class="line">              LOG.info(</span><br><span class="line">                <span class="string">&quot;TRANSCRIPTION RESULT: transcript: &#123;&#125;, confidence &#123;&#125;&quot;</span>,</span><br><span class="line">                alternative.getTranscript(),</span><br><span class="line">                alternative.getConfidence()</span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line">              <span class="comment">// in actual use we would publish to a specific channel tied to the call ID</span></span><br><span class="line">              websocketSession</span><br><span class="line">                .getOpenSessions()</span><br><span class="line">                .forEach(session -&gt; &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    session</span><br><span class="line">                      .getAsyncRemote()</span><br><span class="line">                      .sendText(</span><br><span class="line">                        objectMapper.writeValueAsString(</span><br><span class="line">                          createTranscriptOutputMessage(result.getIsFinal(), alternative)</span><br><span class="line">                        )</span><br><span class="line">                      );</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">      clientStream = client.streamingRecognizeCallable().splitCall(responseObserver);</span><br><span class="line"></span><br><span class="line">      <span class="type">RecognitionConfig</span> <span class="variable">recognitionConfig</span> <span class="operator">=</span> RecognitionConfig</span><br><span class="line">        .newBuilder()</span><br><span class="line">        .setEncoding(AudioEncoding.MULAW)</span><br><span class="line">        .setLanguageCode(<span class="string">&quot;en-US&quot;</span>)</span><br><span class="line">        .setSampleRateHertz(<span class="number">8000</span>)</span><br><span class="line">        .setModel(<span class="string">&quot;phone_call&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">      <span class="type">StreamingRecognitionConfig</span> <span class="variable">streamingRecognitionConfig</span> <span class="operator">=</span> StreamingRecognitionConfig</span><br><span class="line">        .newBuilder()</span><br><span class="line">        .setConfig(recognitionConfig)</span><br><span class="line">        .setInterimResults(<span class="literal">true</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">      <span class="type">StreamingRecognizeRequest</span> <span class="variable">request</span> <span class="operator">=</span> StreamingRecognizeRequest</span><br><span class="line">        .newBuilder()</span><br><span class="line">        .setStreamingConfig(streamingRecognitionConfig)</span><br><span class="line">        .build(); <span class="comment">// The first request in a streaming call has to be a config</span></span><br><span class="line"></span><br><span class="line">      clientStream.send(request);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stopped.get()) &#123;</span><br><span class="line">          <span class="type">long</span> <span class="variable">estimatedTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (estimatedTime &gt;= STREAMING_LIMIT) &#123;</span><br><span class="line">            clientStream.closeSend();</span><br><span class="line">            referenceToStreamController.cancel(); <span class="comment">// remove Observer</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resultEndTimeInMS &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              finalRequestEndTime = isFinalEndTime;</span><br><span class="line">            &#125;</span><br><span class="line">            resultEndTimeInMS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            lastAudioInput = <span class="literal">null</span>;</span><br><span class="line">            lastAudioInput = audioInput;</span><br><span class="line">            audioInput = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ByteString&gt;();</span><br><span class="line"></span><br><span class="line">            restartCounter++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!lastTranscriptWasFinal) &#123;</span><br><span class="line">              System.out.print(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            newStream = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            clientStream =</span><br><span class="line">              client.streamingRecognizeCallable().splitCall(responseObserver);</span><br><span class="line"></span><br><span class="line">            request =</span><br><span class="line">              StreamingRecognizeRequest</span><br><span class="line">                .newBuilder()</span><br><span class="line">                .setStreamingConfig(streamingRecognitionConfig)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">            System.out.println(YELLOW);</span><br><span class="line">            System.out.printf(</span><br><span class="line">              <span class="string">&quot;%d: RESTARTING REQUEST\n&quot;</span>,</span><br><span class="line">              restartCounter * STREAMING_LIMIT</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            startTime = System.currentTimeMillis();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((newStream) &amp;&amp; (lastAudioInput.size() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">              <span class="comment">// if this is the first audio from a new request</span></span><br><span class="line">              <span class="comment">// calculate amount of unfinalized audio from last request</span></span><br><span class="line">              <span class="comment">// resend the audio to the speech client before incoming audio</span></span><br><span class="line">              <span class="type">double</span> <span class="variable">chunkTime</span> <span class="operator">=</span> STREAMING_LIMIT / lastAudioInput.size();</span><br><span class="line">              <span class="comment">// ms length of each chunk in previous request audio arrayList</span></span><br><span class="line">              <span class="keyword">if</span> (chunkTime != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bridgingOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// bridging Offset accounts for time of resent audio</span></span><br><span class="line">                  <span class="comment">// calculated from last request</span></span><br><span class="line">                  bridgingOffset = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bridgingOffset &gt; finalRequestEndTime) &#123;</span><br><span class="line">                  bridgingOffset = finalRequestEndTime;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">chunksFromMs</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(</span><br><span class="line">                  (finalRequestEndTime - bridgingOffset) / chunkTime</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// chunks from MS is number of chunks to resend</span></span><br><span class="line">                bridgingOffset =</span><br><span class="line">                  (<span class="type">int</span>) Math.floor((lastAudioInput.size() - chunksFromMs) * chunkTime);</span><br><span class="line">                <span class="comment">// set bridging offset for next request</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chunksFromMs; i &lt; lastAudioInput.size(); i++) &#123;</span><br><span class="line">                  request =</span><br><span class="line">                    StreamingRecognizeRequest</span><br><span class="line">                      .newBuilder()</span><br><span class="line">                      .setAudioContent(lastAudioInput.get(i))</span><br><span class="line">                      .build();</span><br><span class="line">                  clientStream.send(request);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              newStream = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tempByteString = ByteString.copyFrom(sharedQueue.take());</span><br><span class="line"></span><br><span class="line">            request =</span><br><span class="line">              StreamingRecognizeRequest</span><br><span class="line">                .newBuilder()</span><br><span class="line">                .setAudioContent(tempByteString)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">            audioInput.add(tempByteString);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          clientStream.send(request);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(<span class="string">&quot;Runnable has stopped!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(StreamMessage streamMessage)</span> &#123;</span><br><span class="line">    <span class="type">MediaMessage</span> <span class="variable">mediaMessage</span> <span class="operator">=</span> (MediaMessage) streamMessage;</span><br><span class="line">    <span class="type">byte</span>[] audioBytes = Base64</span><br><span class="line">      .getDecoder()</span><br><span class="line">      .decode(mediaMessage.getMediaMessagePayload().getPayload());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      sharedQueue.put(audioBytes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;Failed to add media message bytes to shared queue&quot;</span>, e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">convertMillisToDate</span><span class="params">(<span class="type">double</span> milliSeconds)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">millis</span> <span class="operator">=</span> (<span class="type">long</span>) milliSeconds;</span><br><span class="line">    <span class="type">DecimalFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>();</span><br><span class="line">    format.setMinimumIntegerDigits(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> String.format(</span><br><span class="line">      <span class="string">&quot;%s:%s /&quot;</span>,</span><br><span class="line">      format.format(TimeUnit.MILLISECONDS.toMinutes(millis)),</span><br><span class="line">      format.format(</span><br><span class="line">        TimeUnit.MILLISECONDS.toSeconds(millis) -</span><br><span class="line">        TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(millis))</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> TranscriptOutputMessage <span class="title function_">createTranscriptOutputMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> isFinal,</span></span><br><span class="line"><span class="params">    SpeechRecognitionAlternative alternative</span></span><br><span class="line"><span class="params">  )</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> TranscriptOutputMessage</span><br><span class="line">      .builder()</span><br><span class="line">      .setText(alternative.getTranscript().strip())</span><br><span class="line">      .setConfidence(alternative.getConfidence())</span><br><span class="line">      .setIsFinal(isFinal)</span><br><span class="line">      .build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Create a factory class <code>StreamingSpeechToTextRunnableFactory.java</code> to dynamically create each runnable with a different websocket connection each time.  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.core.concurrent.speech.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StreamingSpeechToTextRunnableFactory</span> &#123;</span><br><span class="line">StreamingSpeechToTextRunnable <span class="title function_">create</span><span class="params">(Session websocketSession)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Modify the <code>TwilioLiveTranscriptionDemoModule.java</code> (under the <code>guice</code> package) to provide a thread pool executor for the server and register the factory class.   <figure class="highlight java"><figcaption><span>TwilioLiveTranscriptionDemoModule.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.guice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.Provides;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.Singleton;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.assistedinject.FactoryModuleBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.name.Named;</span><br><span class="line"><span class="keyword">import</span> io.dropwizard.Configuration;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.concurrent.speech.google.StreamingSpeechToTextRunnableFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> ru.vyarus.dropwizard.guice.<span class="keyword">module</span>.support.DropwizardAwareModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwilioLiveTranscriptionDemoModule</span> <span class="keyword">extends</span> <span class="title class_">DropwizardAwareModule</span>&lt;Configuration&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">()</span> &#123;</span><br><span class="line">    install(<span class="keyword">new</span> <span class="title class_">FactoryModuleBuilder</span>().build(StreamingSpeechToTextRunnableFactory.class));</span><br><span class="line"></span><br><span class="line">    configuration();</span><br><span class="line">    environment();</span><br><span class="line">    bootstrap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span></span><br><span class="line">  <span class="meta">@Singleton</span></span><br><span class="line">  <span class="meta">@Named(&quot;StreamingCloudSpeechToTextThreadPoolExecutor&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">provideThreadPoolExecutorForCloudSpeechToText</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="number">8</span>,</span><br><span class="line">        <span class="number">100</span>,</span><br><span class="line">        <span class="number">60</span>,</span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span></span><br><span class="line">  <span class="meta">@Singleton</span></span><br><span class="line">  <span class="keyword">public</span> ObjectMapper <span class="title function_">provideObjectMapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bootstrap().getObjectMapper();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Websocket-Speech-to-Text-service"><a href="#Websocket-Speech-to-Text-service" class="headerlink" title="Websocket Speech to Text service"></a>Websocket Speech to Text service</h3><p>In this section we will create a class to manage how each worker in the thread pool is started (e.g. a phone call connects) and stopped (e.g. a phone call ends).  </p>
<ol>
<li>Create a new service class <code>StreamingSpeechToTextService.java</code> under subpackage <code>service.speech.google</code>.   <figure class="highlight java"><figcaption><span>StreamingSpeechToTextService.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.service.speech.google;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Iterables;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.name.Named;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.concurrent.speech.google.StreamingSpeechToTextRunnable;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.concurrent.speech.google.StreamingSpeechToTextRunnableFactory;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.ConnectedMessage;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.MediaMessage;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.StartMessage;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.StreamMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamingSpeechToTextService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(</span><br><span class="line">    StreamingSpeechToTextService.class</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor speechToTextThreadPoolExecutor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StreamingSpeechToTextRunnableFactory streamingSpeechToTextRunnableFactory;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">StreamingSpeechToTextService</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@Named(</span></span></span><br><span class="line"><span class="meta"><span class="params">      &quot;StreamingCloudSpeechToTextThreadPoolExecutor&quot;</span></span></span><br><span class="line"><span class="meta"><span class="params">    )</span> ThreadPoolExecutor threadPoolExecutor,</span></span><br><span class="line"><span class="params">    StreamingSpeechToTextRunnableFactory streamingSpeechToTextRunnableFactory</span></span><br><span class="line"><span class="params">  )</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.speechToTextThreadPoolExecutor = threadPoolExecutor;</span><br><span class="line">    <span class="built_in">this</span>.streamingSpeechToTextRunnableFactory = streamingSpeechToTextRunnableFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleStreamMessage</span><span class="params">(Session session, StreamMessage streamMessage)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (streamMessage.getMessageEventType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> CONNECTED:</span><br><span class="line">        handleConnectedMessage(session, (ConnectedMessage) streamMessage);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> START:</span><br><span class="line">        handleStartMessage(session, (StartMessage) streamMessage);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> MEDIA:</span><br><span class="line">        handleMediaMessage(session, (MediaMessage) streamMessage);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> STOP:</span><br><span class="line">        handleStreamClose(session);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        LOG.error(</span><br><span class="line">          <span class="string">&quot;[sessionId: &#123;&#125;] Unhandled message event type for StreamMessage: &#123;&#125;&quot;</span>,</span><br><span class="line">          session.getId(),</span><br><span class="line">          streamMessage</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleStreamClose</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">    getRunnableFromSession(session)</span><br><span class="line">      .ifPresentOrElse(</span><br><span class="line">        StreamingSpeechToTextRunnable::stop,</span><br><span class="line">        () -&gt; LOG.info(<span class="string">&quot;Attempted to stop session but no runnable found: &#123;&#125;&quot;</span>, session)</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleConnectedMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">    Session session,</span></span><br><span class="line"><span class="params">    ConnectedMessage connectedMessage</span></span><br><span class="line"><span class="params">  )</span> &#123;</span><br><span class="line">    LOG.info(</span><br><span class="line">      <span class="string">&quot;[sessionId: &#123;&#125;] Received connected message: &#123;&#125;&quot;</span>,</span><br><span class="line">      session.getId(),</span><br><span class="line">      connectedMessage</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleStartMessage</span><span class="params">(Session session, StartMessage startMessage)</span> &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;[sessionId: &#123;&#125;] Received start message: &#123;&#125;&quot;</span>, session.getId(), startMessage);</span><br><span class="line">    <span class="type">StreamingSpeechToTextRunnable</span> <span class="variable">streamingSpeechToTextRunnable</span> <span class="operator">=</span> streamingSpeechToTextRunnableFactory.create(</span><br><span class="line">      session</span><br><span class="line">    );</span><br><span class="line">    session.addMessageHandler(streamingSpeechToTextRunnable);</span><br><span class="line">    speechToTextThreadPoolExecutor.execute(streamingSpeechToTextRunnable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleMediaMessage</span><span class="params">(Session session, MediaMessage mediaMessage)</span> &#123;</span><br><span class="line">    <span class="type">StreamingSpeechToTextRunnable</span> <span class="variable">streamingSpeechToTextRunnable</span> <span class="operator">=</span> getRunnableFromSession(</span><br><span class="line">      session</span><br><span class="line">    )</span><br><span class="line">      .orElseThrow();</span><br><span class="line">    streamingSpeechToTextRunnable.onMessage(mediaMessage);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Optional&lt;StreamingSpeechToTextRunnable&gt; <span class="title function_">getRunnableFromSession</span><span class="params">(</span></span><br><span class="line"><span class="params">    Session session</span></span><br><span class="line"><span class="params">  )</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Optional.of(</span><br><span class="line">        (StreamingSpeechToTextRunnable) Iterables.getOnlyElement(</span><br><span class="line">          session.getMessageHandlers()</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      LOG.error(<span class="string">&quot;Failed to get runnable from session: &#123;&#125;&quot;</span>, session, e);</span><br><span class="line">      <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Modify the existing <code>TwilioAudioStreamWebsocketResource.java</code> websocket resource to use the service class.  In particular, we want to start the worker when a new websocket connection is made <code>StreamingSpeechToTextService#handleStreamMessage</code> and stop an existing worker when a phone call ends via <code>StreamingSpeechToTextService#handleStreamClose</code>.   <figure class="highlight java"><figcaption><span>TwilioAudioStreamWebsocketResource.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.sethmachine.twiliolivetranscriptiondemo.resources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.CloseReason;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnClose;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.codahale.metrics.annotation.ExceptionMetered;</span><br><span class="line"><span class="keyword">import</span> com.codahale.metrics.annotation.Metered;</span><br><span class="line"><span class="keyword">import</span> com.codahale.metrics.annotation.Timed;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.core.model.twilio.stream.messages.StreamMessage;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.guice.GuiceWebsocketConfigurator;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.service.speech.google.StreamingSpeechToTextService;</span><br><span class="line"><span class="keyword">import</span> io.sethmachine.twiliolivetranscriptiondemo.service.twilio.stream.StreamMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Metered</span></span><br><span class="line"><span class="meta">@Timed</span></span><br><span class="line"><span class="meta">@ExceptionMetered</span></span><br><span class="line"><span class="meta">@ServerEndpoint(</span></span><br><span class="line"><span class="meta">    value = &quot;/twilio/websocket/audio-stream&quot;,</span></span><br><span class="line"><span class="meta">    configurator = GuiceWebsocketConfigurator.class,</span></span><br><span class="line"><span class="meta">    decoders = &#123; StreamMessageDecoder.class &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwilioAudioStreamWebsocketResource</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOG</span> <span class="operator">=</span> LoggerFactory.getLogger(</span><br><span class="line">      TwilioAudioStreamWebsocketResource.class</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> StreamingSpeechToTextService streamingSpeechToTextService;</span><br><span class="line">  <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TwilioAudioStreamWebsocketResource</span><span class="params">(</span></span><br><span class="line"><span class="params">      StreamingSpeechToTextService streamingSpeechToTextService,</span></span><br><span class="line"><span class="params">      ObjectMapper objectMapper</span></span><br><span class="line"><span class="params">  )</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.streamingSpeechToTextService = streamingSpeechToTextService;</span><br><span class="line">    <span class="built_in">this</span>.objectMapper = objectMapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnOpen</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOnOpen</span><span class="params">(<span class="keyword">final</span> Session session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    LOG.info(</span><br><span class="line">        <span class="string">&quot;[sessionId: &#123;&#125;] Websocket session connection opened: &#123;&#125;&quot;</span>,</span><br><span class="line">        session.getId(),</span><br><span class="line">        session</span><br><span class="line">    );</span><br><span class="line">    session.getAsyncRemote().sendText(<span class="string">&quot;Ready to receive live transcription results&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.session = session;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnMessage</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOnMsg</span><span class="params">(<span class="keyword">final</span> Session session, StreamMessage streamMessage)</span> &#123;</span><br><span class="line">    streamingSpeechToTextService.handleStreamMessage(session, streamMessage);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OnClose</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myOnClose</span><span class="params">(<span class="keyword">final</span> Session session, CloseReason cr)</span> &#123;</span><br><span class="line">    LOG.info(<span class="string">&quot;Closed connection! reason: &#123;&#125;, session: &#123;&#125;&quot;</span>, cr, session);</span><br><span class="line">    streamingSpeechToTextService.handleStreamClose(session);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Live-Transcription"><a href="#Live-Transcription" class="headerlink" title="Live Transcription"></a>Live Transcription</h2><p>With all the business logic completed, we can test live transcription with another phone call to the phone number we set up in <a href="#buy-and-configure-a-phone-number">Buy and configure a phone number</a>.</p>
<ol>
<li> Run the Java server </li>
<li>Expose the server via ngrok <code>ngrok http 8080</code></li>
<li>Copy the ngrok forwarding URL (looks something like <code>https://5e32-73-125-186-111.ngrok-free.app</code>)</li>
<li>Update the Twilio webhook configuration for when a call comes in, it should look something like <code>https://5e32-73-125-186-111.ngrok-free.app/twilio/webhooks/inbound-call</code>.  See <a href="#buy-and-configure-a-phone-number">Buy and configure a phone number</a> if you need a refresher on how to do this.  </li>
<li>Open <a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/piesocket-websocket-teste/oilioclnckkoijghdniegedkbocfpnip">PieSocket WebSocket Tester</a> in Chrome browser.  </li>
<li>Enter <code>ws://localhost:8080/twilio/websocket/audio-stream</code> for Location and and hit Connect.<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/test-live-transcription/piewebsocket-part-1.png" alt="Connect PieSocket"></li>
<li>Confirm the connection is successful, it should look like below:<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/test-live-transcription/piewebsocket-part-2.png" alt="Connect PieSocket Result"></li>
<li>Place a phone call to the purchased Twilio phone number.  After the connection message plays, speak English like “I would like to buy a bicycle”.  You should observe transcription output in both PieSocket and the Java console!<br><img src="/2023/11/17/live-transcription-with-twilio-and-google/test-live-transcription/piewebsocket-part-3.png" alt="PieSocket Live Transcription Output"><br><img src="/2023/11/17/live-transcription-with-twilio-and-google/test-live-transcription/piewebsocket-part-4.png" alt="Java Live Transcription Output"></li>
</ol>
<p>If you’re seeing live transcription output as you speak, congratulations, it’s working!  You can continue speaking and see the live transcription stream output.  It will end after 60 seconds have passed or the call has hung up (whichever happens first).  </p>
<p>The output comes in two flavors depending on whether the result is final or not:</p>
<ul>
<li><code>&#123;&quot;text&quot;:&quot;like to buy a&quot;,&quot;confidence&quot;:0.0,&quot;isFinal&quot;:false&#125;</code> is a non final result as indicate by <code>&quot;isFinal&quot;</code> being set to <code>false</code>.  </li>
<li><code>&#123;&quot;text&quot;:&quot;like to buy a bicycle&quot;,&quot;confidence&quot;:0.7173231,&quot;isFinal&quot;:true&#125;</code> is a final result, and even has a confidence score associated with it.  </li>
</ul>
<p>The speech to text algorithm is constantly listening to speech input and waiting for it to end before producing a final result.  Depending upon the application, it may be useful to have both outputs, or only use the final one.     </p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We have created a Java web server that live transcribes phone calls with Twilio and Google Cloud Speech to Text.  The server is able to handle incoming media streams from Twilio, stream these to Google Cloud Speech to Text, and finally stream the live transcription results over a WebSocket connection for an end user or application to use.</p>
<p>Nevertheless, there are still several key areas we did not address to make this system production ready.  Each of these would be good follow-up projects to expand upon what we built:</p>
<ul>
<li>Authenticate incoming media stream.  The ingestion websocket is not secure.  We need to prove that Twilio is sending in the audio bytes, otherwise a malicious actor could send in their own audio bytes!    </li>
<li>Secure live transcription websocket output.  The current implementation broadcasts all transcription results through a public and insecure websocket.  We need to add security to make sure only authorized users (e.g. those on the call) can see the live transcription output.  </li>
<li>Scalability.  Because websockets are stateful, it can be non-trivial to scale the WebSockets server.  See this <a target="_blank" rel="noopener" href="https://ably.com/topic/the-challenge-of-scaling-websockets">Ably article</a> on why this is challenging.</li>
<li>Handling multiple speakers or channels.  The current system simple transcribes all audio bytes into a single transcription output.  Twilio provides some metadata to help distinguish audio from either speaker on the phone call.  This way we can distinguish between who said what when (e.g. a form of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Speaker_diarisation">speaker diarization</a>).  </li>
</ul>
<p>Have thoughts on how to improve this or scale it for production, or need help getting the demo working?  Please leave a comment and I’d be happy to discuss more with you!</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/05/17/universal-sound-board/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-11-18 16:17:22
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Java/" title="Java">
                        #Java
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Dropwizard/" title="Dropwizard">
                        #Dropwizard
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Twilio/" title="Twilio">
                        #Twilio
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Transcription/" title="Transcription">
                        #Transcription
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/AI/" title="AI">
                        #AI
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Calling/" title="Calling">
                        #Calling
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Google/" title="Google">
                        #Google
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Gcloud/" title="Gcloud">
                        #Gcloud
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Speech-to-Text/" title="Speech to Text">
                        #Speech to Text
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Websockets/" title="Websockets">
                        #Websockets
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2025/01/06/richchk/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSockets-Approach"><span class="toc-text">WebSockets Approach</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setting-up-Java-web-server"><span class="toc-text">Setting up Java web server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handle-Inbound-Calls"><span class="toc-text">Handle Inbound Calls</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handle-Websocket-audio-stream"><span class="toc-text">Handle Websocket audio stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Expose-server-with-ngrok"><span class="toc-text">Expose server with ngrok</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buy-and-configure-a-phone-number"><span class="toc-text">Buy and configure a phone number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Model-Twilio-Stream-messages"><span class="toc-text">Model Twilio Stream messages</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-up-Google-Cloud-Speech-to-Text"><span class="toc-text">Set up Google Cloud Speech to Text</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-credentials"><span class="toc-text">Create credentials</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add-credentials-to-server"><span class="toc-text">Add credentials to server</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Live-transcription-setup"><span class="toc-text">Live transcription setup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Speech-To-Text-thread-pool"><span class="toc-text">Speech To Text thread pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Websocket-Speech-to-Text-service"><span class="toc-text">Websocket Speech to Text service</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Live-Transcription"><span class="toc-text">Live Transcription</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-text">Conclusion</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        


  <div id="disqus_thread"></div>
  <script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://sethmachine01.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>






      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/sethmachine">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
        <li>
          
            <a title="email" href="mailto:sdworman@brandeis.edu">
              <i class="iconfont icon-envelope"></i>
            </a>
            
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © sethmachine 2025</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://icons8.com/icons/set/espresso-cup">Espresso Cup icon by Icons8</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        


        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Live%20Transcription%20with%20Twilio%20and%20Google%20using%20Java + '&url=' + http%3A%2F%2Fexample.com%2F2023%2F11%2F17%2Flive-transcription-with-twilio-and-google%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2023/11/17/live-transcription-with-twilio-and-google/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
